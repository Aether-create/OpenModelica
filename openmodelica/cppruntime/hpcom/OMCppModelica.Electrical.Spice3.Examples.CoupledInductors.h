#pragma once
#if defined(__TRICORE__) || defined(__vxworks)
  #define BOOST_EXTENSION_SYSTEM_DECL
  #define BOOST_EXTENSION_EVENTHANDLING_DECL
#endif


#include "System/SystemDefaultImplementation.h"
/*includes removed for static linking not needed any more
#ifdef RUNTIME_STATIC_LINKING
  #include <boost/shared_ptr.hpp>
  #include <boost/weak_ptr.hpp>
  #include <boost/numeric/ublas/vector.hpp>
  #include <boost/numeric/ublas/matrix.hpp>
  #include <string>
  #include <vector>
  #include <map>

  using std::string;
  using std::vector;
  using std::map;

  #include <SimCoreFactory/Policies/FactoryConfig.h>
  #include <SimController/ISimController.h>
  #include <System/IMixedSystem.h>

  #include <boost/numeric/ublas/matrix_sparse.hpp>
  typedef uBlas::compressed_matrix<double, uBlas::column_major, 0, uBlas::unbounded_array<int>, uBlas::unbounded_array<double> > SparseMatrix;
#endif //RUNTIME_STATIC_LINKING
*/
//Forward declaration to speed-up the compilation process
class Functions;
class EventHandling;
class DiscreteEvents;
class CoupledInductorsAlgloop53;

/*****************************************************************************
*
* Simulation code for CoupledInductors generated by the OpenModelica Compiler.
* System class CoupledInductors implements the Interface IMixedSystem
*
*****************************************************************************/
#include <omp.h>

class CoupledInductors: public IContinuous, public IEvent, public IStepEvent, public ITime, public ISystemProperties , public SystemDefaultImplementation
{
friend class CoupledInductorsAlgloop53;
public:

    CoupledInductors(IGlobalSettings* globalSettings, boost::shared_ptr<IAlgLoopSolverFactory> nonlinsolverfactor, boost::shared_ptr<ISimData> sim_data, boost::shared_ptr<ISimVars> sim_vars);
    CoupledInductors(CoupledInductors &instance);
    
    virtual ~CoupledInductors();
    
    /// Releases the Modelica System
    virtual void destroy();
    /// Provide number (dimension) of variables according to the index
    virtual int getDimContinuousStates() const;
    /// Provide number (dimension) of boolean variables
    virtual int getDimBoolean() const;
    /// Provide number (dimension) of integer variables
    virtual int getDimInteger() const;
    /// Provide number (dimension) of real variables
    virtual int getDimReal() const ;
    /// Provide number (dimension) of string variables
    virtual int getDimString() const ;
    /// Provide number (dimension) of right hand sides (equations and/or residuals) according to the index
    virtual int getDimRHS()const;
    
    //Resets all time events
    
    // Provide variables with given index to the system
    virtual void getContinuousStates(double* z);
    virtual void getNominalStates(double* z);
    // Set variables with given index to the system
    virtual void setContinuousStates(const double* z);
    
    // Update transfer behavior of the system of equations according to command given by solver
    virtual bool evaluateAll(const UPDATETYPE command = IContinuous::UNDEF_UPDATE);
    virtual void evaluateODE(const UPDATETYPE command = IContinuous::UNDEF_UPDATE);
    virtual void evaluateZeroFuncs(const UPDATETYPE command = IContinuous::UNDEF_UPDATE);
    virtual bool evaluateConditions(const UPDATETYPE command);
    
    // Provide the right hand side (according to the index)
    virtual void getRHS(double* f);
    virtual void setRHS(const double* f);
    
    //Provide number (dimension) of zero functions
    virtual int getDimZeroFunc();
    //Provides current values of root/zero functions
    virtual void getZeroFunc(double* f);
    virtual void setConditions(bool* c);
    virtual void getConditions(bool* c);
    
    //Called to handle an event
    virtual void handleEvent(const bool* events);
    //Checks if a discrete variable has changed and triggers an event
    virtual bool checkForDiscreteEvents();
    virtual bool isStepEvent();
    //sets the terminal status
    virtual void setTerminal(bool);
    //returns the terminal status
    virtual bool terminal();
    
    
    
    // M is regular
    virtual bool isODE();
    // M is singular
    virtual bool isAlgebraic();
    
    virtual int getDimTimeEvent() const;
    //gibt die Time events (Startzeit und Frequenz) zuruck
    virtual void getTimeEvent(time_event_type& time_events);
    //Wird vom Solver zur Behandlung der Time events aufgerufen (wenn zero_sign[i] = 0  kein time event,zero_sign[i] = n  Anzahl von vorgekommen time events )
    virtual void handleTimeEvent(int* time_events);
    /// Set current integration time
    virtual void setTime(const double& time);
    
    // System is able to provide the Jacobian symbolically
    virtual bool provideSymbolicJacobian();
    
    virtual bool stepCompleted(double time);
    virtual bool stepStarted(double time);
    
    
    /// Provide boolean variables
    virtual void getBoolean(bool* z);
    /// Provide integer variables
    virtual void getInteger(int* z);
    /// Provide real variables
    virtual void getReal(double* z);
    /// Provide real variables
    virtual void getString(std::string* z);
    /// Provide boolean variables
    virtual void setBoolean(const bool* z);
    /// Provide integer variables
    virtual void setInteger(const int* z);
    /// Provide real variables
    virtual void setReal(const double* z);
    /// Provide real variables
    virtual void setString(const std::string* z);
    virtual bool getCondition(unsigned int index);
    
    boost::shared_ptr<IAlgLoopSolverFactory> getAlgLoopSolverFactory();
    boost::shared_ptr<ISimData> getSimData();
    
protected:
    //Methods:
    void initializeAlgloopSolverVariables();
    void initializeJacAlgloopSolverVariables();
    void deleteAlgloopSolverVariables();
    void deleteJacAlgloopSolverVariables();
    void initializeAlgloopSolverVariables_0();
    void deleteAlgloopSolverVariables_0();
    bool isConsistent();
    //Called to handle all events occured at same time
    bool handleSystemEvents(bool* events);
    //Saves all variables before an event is handled, is needed for the pre, edge and change operator
    void saveAll();
    
    void defineAlgVars();
    void defineDiscreteAlgVars();
    void defineIntAlgVars();
    void defineBoolAlgVars();
    void defineParameterRealVars();
    void defineParameterIntVars();
    void defineParameterBoolVars();
    void defineAliasRealVars();
    void defineAliasIntVars();
    void defineAliasBoolVars();
    void defineMixedArrayVars();
    
    void getJacobian(SparseMatrix& matrix);
    void deleteObjects();
    
    //Variables:
    boost::shared_ptr<EventHandling> _event_handling;
    boost::shared_ptr<DiscreteEvents> _discrete_events;
    
    //pointer to simVars-array to speedup simulation and compile time
    double* _pointerToRealVars;
    int* _pointerToIntVars;
    bool* _pointerToBoolVars;
    
     /*parameter real vars*/
     #define _C1_P_C _pointerToRealVars[38]
     #define _C1_P_IC _pointerToRealVars[39]
     #define _C2_P_C _pointerToRealVars[40]
     #define _C2_P_IC _pointerToRealVars[41]
     #define _L1_P_IC _pointerToRealVars[42]
     #define _L1_P_L _pointerToRealVars[43]
     #define _L2_P_IC _pointerToRealVars[44]
     #define _L2_P_L _pointerToRealVars[45]
     #define _L3_P_IC _pointerToRealVars[46]
     #define _L3_P_L _pointerToRealVars[47]
     #define _R1_P_R _pointerToRealVars[48]
     #define _R2_P_R _pointerToRealVars[49]
     #define _R3_P_R _pointerToRealVars[50]
     #define _R4_P_R _pointerToRealVars[51]
     #define _R5_P_R _pointerToRealVars[52]
     #define _k1_P_k _pointerToRealVars[53]
     #define _k2_P_k _pointerToRealVars[54]
     #define _k3_P_k _pointerToRealVars[55]
     #define _sineVoltage_P_FREQ _pointerToRealVars[56]
     #define _sineVoltage_P_TD _pointerToRealVars[57]
     #define _sineVoltage_P_THETA _pointerToRealVars[58]
     #define _sineVoltage_P_VA _pointerToRealVars[59]
     #define _sineVoltage_P_VO _pointerToRealVars[60]
     /*parameter int vars*/
     /*parameter bool vars*/
     #define _C1_P_UIC _pointerToBoolVars[0]
     #define _C2_P_UIC _pointerToBoolVars[1]
     #define _L1_P_UIC _pointerToBoolVars[2]
     #define _L2_P_UIC _pointerToBoolVars[3]
     #define _L3_P_UIC _pointerToBoolVars[4]
    /*string parameter variables*/
     /*string alias variables*/
     /*external variables*/
     /*alias real vars*/
     #define _C1_P_n_P_i _pointerToRealVars[10]
     #define _C1_P_n_P_v _pointerToRealVars[27]
     #define _C1_P_p_P_i _pointerToRealVars[10]
     #define _C1_P_p_P_v _pointerToRealVars[0]
     #define _C1_P_v _pointerToRealVars[0]
     #define _C2_P_n_P_i _pointerToRealVars[11]
     #define _C2_P_n_P_v _pointerToRealVars[27]
     #define _C2_P_p_P_i _pointerToRealVars[11]
     #define _C2_P_p_P_v _pointerToRealVars[1]
     #define _C2_P_v _pointerToRealVars[1]
     #define _L1_P_ICP_P_L _pointerToRealVars[43]
     #define _L1_P_i _pointerToRealVars[2]
     #define _L1_P_n_P_i _pointerToRealVars[2]
     #define _L1_P_n_P_v _pointerToRealVars[27]
     #define _L1_P_p_P_i _pointerToRealVars[2]
     #define _L1_P_p_P_v _pointerToRealVars[14]
     #define _L2_P_ICP_P_L _pointerToRealVars[45]
     #define _L2_P_i _pointerToRealVars[3]
     #define _L2_P_n_P_i _pointerToRealVars[3]
     #define _L2_P_n_P_v _pointerToRealVars[27]
     #define _L2_P_p_P_i _pointerToRealVars[3]
     #define _L2_P_p_P_v _pointerToRealVars[17]
     #define _L3_P_ICP_P_L _pointerToRealVars[47]
     #define _L3_P_i _pointerToRealVars[4]
     #define _L3_P_n_P_i _pointerToRealVars[4]
     #define _L3_P_n_P_v _pointerToRealVars[27]
     #define _L3_P_p_P_i _pointerToRealVars[4]
     #define _L3_P_p_P_v _pointerToRealVars[20]
     #define _R1_P_i _pointerToRealVars[2]
     #define _R1_P_n_P_i _pointerToRealVars[2]
     #define _R1_P_n_P_v _pointerToRealVars[14]
     #define _R1_P_p_P_i _pointerToRealVars[2]
     #define _R1_P_p_P_v _pointerToRealVars[37]
     #define _R2_P_i _pointerToRealVars[3]
     #define _R2_P_n_P_i _pointerToRealVars[3]
     #define _R2_P_n_P_v _pointerToRealVars[17]
     #define _R2_P_p_P_i _pointerToRealVars[3]
     #define _R2_P_p_P_v _pointerToRealVars[0]
     #define _R3_P_n_P_i _pointerToRealVars[23]
     #define _R3_P_n_P_v _pointerToRealVars[27]
     #define _R3_P_p_P_i _pointerToRealVars[23]
     #define _R3_P_p_P_v _pointerToRealVars[0]
     #define _R3_P_v _pointerToRealVars[0]
     #define _R4_P_i _pointerToRealVars[4]
     #define _R4_P_n_P_i _pointerToRealVars[4]
     #define _R4_P_n_P_v _pointerToRealVars[20]
     #define _R4_P_p_P_i _pointerToRealVars[4]
     #define _R4_P_p_P_v _pointerToRealVars[1]
     #define _R5_P_n_P_i _pointerToRealVars[25]
     #define _R5_P_n_P_v _pointerToRealVars[27]
     #define _R5_P_p_P_i _pointerToRealVars[25]
     #define _R5_P_p_P_v _pointerToRealVars[1]
     #define _R5_P_v _pointerToRealVars[1]
     #define _k1_P_inductiveCouplePin1_P_L _pointerToRealVars[43]
     #define _k1_P_inductiveCouplePin1_P_di _pointerToRealVars[12]
     #define _k1_P_inductiveCouplePin2_P_L _pointerToRealVars[45]
     #define _k1_P_inductiveCouplePin2_P_di _pointerToRealVars[15]
     #define _k2_P_inductiveCouplePin1_P_L _pointerToRealVars[43]
     #define _k2_P_inductiveCouplePin1_P_di _pointerToRealVars[12]
     #define _k2_P_inductiveCouplePin2_P_L _pointerToRealVars[47]
     #define _k2_P_inductiveCouplePin2_P_di _pointerToRealVars[18]
     #define _k3_P_inductiveCouplePin1_P_L _pointerToRealVars[47]
     #define _k3_P_inductiveCouplePin1_P_di _pointerToRealVars[18]
     #define _k3_P_inductiveCouplePin2_P_L _pointerToRealVars[45]
     #define _k3_P_inductiveCouplePin2_P_di _pointerToRealVars[15]
     #define _sineVoltage_P_i _pointerToRealVars[2]
     #define _sineVoltage_P_n_P_i _pointerToRealVars[2]
     #define _sineVoltage_P_n_P_v _pointerToRealVars[27]
     #define _sineVoltage_P_p_P_i _pointerToRealVars[2]
     #define _sineVoltage_P_p_P_v _pointerToRealVars[37]
     /*alias int vars*/
      /*alias bool vars*/
     /*string algvars*/
    //Variables saved for pre, edge and change operator
     /*real algvars*/
    #define _C1_P_i _pointerToRealVars[10]
    #define _C2_P_i _pointerToRealVars[11]
    #define _L1_P_ICP_P_di _pointerToRealVars[12]
    #define _L1_P_ICP_P_v _pointerToRealVars[13]
    #define _L1_P_v _pointerToRealVars[14]
    #define _L2_P_ICP_P_di _pointerToRealVars[15]
    #define _L2_P_ICP_P_v _pointerToRealVars[16]
    #define _L2_P_v _pointerToRealVars[17]
    #define _L3_P_ICP_P_di _pointerToRealVars[18]
    #define _L3_P_ICP_P_v _pointerToRealVars[19]
    #define _L3_P_v _pointerToRealVars[20]
    #define _R1_P_v _pointerToRealVars[21]
    #define _R2_P_v _pointerToRealVars[22]
    #define _R3_P_i _pointerToRealVars[23]
    #define _R4_P_v _pointerToRealVars[24]
    #define _R5_P_i _pointerToRealVars[25]
    #define _ground_P_p_P_i _pointerToRealVars[26]
    #define _ground_P_p_P_v _pointerToRealVars[27]
    #define _k1_P_M _pointerToRealVars[28]
    #define _k1_P_inductiveCouplePin1_P_v _pointerToRealVars[29]
    #define _k1_P_inductiveCouplePin2_P_v _pointerToRealVars[30]
    #define _k2_P_M _pointerToRealVars[31]
    #define _k2_P_inductiveCouplePin1_P_v _pointerToRealVars[32]
    #define _k2_P_inductiveCouplePin2_P_v _pointerToRealVars[33]
    #define _k3_P_M _pointerToRealVars[34]
    #define _k3_P_inductiveCouplePin1_P_v _pointerToRealVars[35]
    #define _k3_P_inductiveCouplePin2_P_v _pointerToRealVars[36]
    #define _sineVoltage_P_v _pointerToRealVars[37]
    /*discrete algvars*/
     /*int algvars*/
    /*bool algvars*/
     /*mixed array variables*/
    Functions* _functions;
    
    boost::shared_ptr<IAlgLoopSolverFactory> _algLoopSolverFactory;    ///< Factory that provides an appropriate solver
    boost::shared_ptr<IAlgLoop>  //Algloop  which holds equation system
         _algLoop53;
    boost::shared_ptr<IAlgLoopSolver>
         _algLoopSolver53;        ///< Solver for algebraic loop */
     bool* _conditions053;
     bool* _conditions153;
     double* _algloop53Vars;




    /*! Index of the first equation. We use this to calculate the offset of an equation in the
       equation array given the index of the equation.*/
     int first_equation_index;
      /*! Equations*/
      FORCE_INLINE void evaluate_39();
      /*! Equations*/
      FORCE_INLINE void evaluate_40();
      /*! Equations*/
      FORCE_INLINE void evaluate_41();
      /*! Equations*/
      FORCE_INLINE void evaluate_42();
      /*! Equations*/
      FORCE_INLINE void evaluate_43();
      /*! Equations*/
      FORCE_INLINE void evaluate_44();
      /*! Equations*/
      FORCE_INLINE void evaluate_45();
      /*! Equations*/
      FORCE_INLINE void evaluate_46();
      /*! Equations*/
      FORCE_INLINE void evaluate_47();
      /*! Equations*/
      FORCE_INLINE void evaluate_48();
      /*! Equations*/
      FORCE_INLINE void evaluate_49();
      /*! Equations*/
      FORCE_INLINE void evaluate_50();
      /*! Equations*/
      FORCE_INLINE void evaluate_51();
      /*! Equations*/
      FORCE_INLINE void evaluate_52();
      /*! Equations*/
      FORCE_INLINE void evaluate_53();
      /*! Equations*/
      FORCE_INLINE void evaluate_54();
      /*! Equations*/
      FORCE_INLINE void evaluate_55();
      /*! Equations*/
      FORCE_INLINE void evaluate_56();
      /*! Equations*/
      FORCE_INLINE void evaluate_63();
      /*! Equations*/
      FORCE_INLINE void evaluate_62();
      /*! Equations*/
      FORCE_INLINE void evaluate_61();
      /*! Equations*/
      FORCE_INLINE void evaluate_60();
      /*! Equations*/
      FORCE_INLINE void evaluate_59();
      /*! Equations*/
      FORCE_INLINE void evaluate_58();
      /*! Equations*/
      FORCE_INLINE void evaluate_57();
    static long unsigned int getThreadNumber()
    {
      return (long unsigned int)omp_get_thread_num();
    }

    void defineAlgVars_0();
    void defineParameterRealVars_0();
    void defineParameterBoolVars_0();
    void defineAliasRealVars_0();
    void defineConstVals();FORCE_INLINE void evaluateParallel(const UPDATETYPE command, bool evaluateODE);
    UPDATETYPE _command;
    bool _evaluateODE;
 };